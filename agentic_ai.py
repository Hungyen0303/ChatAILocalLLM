from typing import Dict

from llama_cpp import List
from pyparsing import Any
from action_plan import ActionPlan, get_json_response
from function_result import FunctionResult
from llm_processor import MCP_AVAILABLE, classify_by_topic_handler, classify_handler, format_mcp_result, generate_classify_result, generate_simple_response, search_handler
from mcp_client import process_filesystem_query


class AgenticProcessor:
    def __init__(self):
        self.context_data = {}  # L∆∞u tr·ªØ d·ªØ li·ªáu gi·ªØa c√°c b∆∞·ªõc
        self.execution_history = []  # L·ªãch s·ª≠ th·ª±c hi·ªán
        
    def execute_step(self, step: Dict[str, Any], step_index: int, prompt: str) -> FunctionResult:
        """Th·ª±c hi·ªán m·ªôt b∆∞·ªõc trong action plan"""
        intent = step.get('function', '')
        step_description = step.get('description', '')
        print(f"Executing step {step_index + 1}: {intent} - {step_description}")
        try:            
            if intent == 'search':
                return self._execute_search(prompt, step)
            elif intent == 'scan':
                return self._execute_scan(prompt, step)
            elif intent == 'classify':
                return self._execute_classify(prompt, step)
            elif intent == 'export':
                return self._execute_export(prompt, step)
            elif intent == 'classify_by_topic':
                return self._execute_classify_by_topic(prompt, step)
            else:
                return FunctionResult(
                    success=False,
                    error=f"H√†nh ƒë·ªông: {intent}"
                )
                
        except Exception as e:
            print(f"Error executing step {step_index + 1}: {e}")
            return FunctionResult(
                success=False,
                error=str(e)
            )
    
    def _execute_search(self, prompt: str, step: Dict[str, Any]) -> FunctionResult:
        """Th·ª±c hi·ªán search v·ªõi x·ª≠ l√Ω l·ªói"""
        try:
            keyword = search_handler(prompt)
            if not keyword:
                return FunctionResult(
                    success=False,
                    error="Kh√¥ng th·ªÉ x√°c ƒë·ªãnh t·ª´ kh√≥a t√¨m ki·∫øm",
                    missing_data=["search_keyword"]
                )
            print(f"Searching for keyword: {keyword}")
            
            mcp_result = process_filesystem_query(keyword, "search")
            formatted_result = format_mcp_result(mcp_result, 'search', prompt)
            
            # L∆∞u k·∫øt qu·∫£ v√†o context
            self.context_data['search_results'] = mcp_result
            self.context_data['search_keyword'] = keyword
            
            return FunctionResult(
                success=True,
                data=formatted_result,
            )
            
        except Exception as e:
            return FunctionResult(
                success=False,
                error=f"Search failed: {str(e)}"
            )
    
    def _execute_scan(self, prompt: str, step: Dict[str, Any]) -> FunctionResult:
        """Th·ª±c hi·ªán scan v·ªõi x·ª≠ l√Ω l·ªói"""
        try:
            # C√≥ th·ªÉ s·ª≠ d·ª•ng d·ªØ li·ªáu t·ª´ b∆∞·ªõc tr∆∞·ªõc
            directory = self.context_data.get('target_directory', "")
            mcp_result = process_filesystem_query(directory, "scan")
            formatted_result = format_mcp_result(mcp_result, 'scan', prompt)
            
            # L∆∞u k·∫øt qu·∫£ v√†o context
            self.context_data['scan_results'] = mcp_result
            
            return FunctionResult(
                success=True,
                data=formatted_result,
            )
            
        except Exception as e:
            return FunctionResult(
                success=False,
                error=f"Scan failed: {str(e)}"
            )
    
    def _execute_classify(self, prompt: str, step: Dict[str, Any]) -> FunctionResult:
        """Th·ª±c hi·ªán classify v·ªõi x·ª≠ l√Ω l·ªói"""
        try:
            targets = classify_handler(prompt)
            
            # S·ª≠ d·ª•ng scan results t·ª´ b∆∞·ªõc tr∆∞·ªõc n·∫øu c√≥
            mcp_files = self.context_data.get('scan_results')
            if not mcp_files:
                mcp_files = process_filesystem_query("", "scan_all")
            
            if not mcp_files:
                return FunctionResult(
                    success=False,
                    error="Kh√¥ng t√¨m th·∫•y files ƒë·ªÉ ph√¢n lo·∫°i",
                    missing_data=["file_list"]
                )
            
            mcp_result = generate_classify_result(mcp_files, targets)
            formatted_result = format_mcp_result(mcp_result, 'classify', prompt)
            
            # L∆∞u k·∫øt qu·∫£ v√†o context
            self.context_data['classify_results'] = mcp_result
            
            return FunctionResult(
                success=True,
                data=formatted_result,
            )
            
        except Exception as e:
            return FunctionResult(
                success=False,
                error=f"Classification failed: {str(e)}"
            )
    
    def _execute_export(self, prompt: str, step: Dict[str, Any]) -> FunctionResult:
        """Th·ª±c hi·ªán export v·ªõi x·ª≠ l√Ω l·ªói"""
        try:
            # C√≥ th·ªÉ s·ª≠ d·ª•ng d·ªØ li·ªáu t·ª´ c√°c b∆∞·ªõc tr∆∞·ªõc
            export_data = self.context_data.get('classify_results') or \
                         self.context_data.get('scan_results') or \
                         self.context_data.get('search_results')
            
            if not export_data:
                return FunctionResult(
                    success=False,
                    error="Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t metadata",
                    missing_data=["export_data"]
                )
            
            mcp_result = process_filesystem_query("", "export")
            formatted_result = "Xu·∫•t metadata th√†nh c√¥ng"
            
            return FunctionResult(
                success=True,
                data=formatted_result,
            )
            
        except Exception as e:
            return FunctionResult(
                success=False,
                error=f"Export failed: {str(e)}"
            )
    
    def _execute_classify_by_topic(self, prompt: str, step: Dict[str, Any]) -> FunctionResult:
        """Th·ª±c hi·ªán classify by topic v·ªõi x·ª≠ l√Ω l·ªói"""
        try:
            topic = classify_by_topic_handler(prompt)
            
            if not topic:
                return FunctionResult(
                    success=False,
                    error="Kh√¥ng th·ªÉ x√°c ƒë·ªãnh ch·ªß ƒë·ªÅ ph√¢n lo·∫°i",
                    missing_data=["topic"]
                )
            print(f"Classifying by topic: {topic}")
            mcp_result = process_filesystem_query(topic, "classify_by_topic")
            formatted_result = format_mcp_result(mcp_result, 'classify_by_topic', prompt)
            
            # L∆∞u k·∫øt qu·∫£ v√†o context
            self.context_data['classify_by_topic_results'] = mcp_result
            
            return FunctionResult(
                success=True,
                data=formatted_result,
            )
            
        except Exception as e:
            return FunctionResult(
                success=False,
                error=f"Classify by topic {topic}: {str(e)}"
            )
    
    def handle_step_failure(self, failed_result: FunctionResult, step_index: int, 
                           remaining_steps: List[Dict[str, Any]], prompt: str) -> str:
        """X·ª≠ l√Ω khi m·ªôt b∆∞·ªõc th·∫•t b·∫°i"""
        error_msg = f"‚ùå B∆∞·ªõc {step_index + 1} th·∫•t b·∫°i: {failed_result.error}\n"
        
        # Ki·ªÉm tra xem c√≥ th·ªÉ ti·∫øp t·ª•c v·ªõi d·ªØ li·ªáu hi·ªán c√≥ kh√¥ng
        if failed_result.missing_data:
            error_msg += f"‚ö†Ô∏è  Thi·∫øu d·ªØ li·ªáu: {', '.join(failed_result.missing_data)}\n"
            
            # Th·ª≠ t√¨m d·ªØ li·ªáu thay th·∫ø t·ª´ context
            if self._can_continue_with_context(failed_result.missing_data):
                error_msg += "üîÑ T√¨m th·∫•y d·ªØ li·ªáu thay th·∫ø, ti·∫øp t·ª•c x·ª≠ l√Ω...\n"
                return error_msg
        
        # Ki·ªÉm tra xem c√≥ th·ªÉ b·ªè qua b∆∞·ªõc n√†y kh√¥ng
        if self._can_skip_step(step_index, remaining_steps):
            error_msg += "‚è≠Ô∏è  B·ªè qua b∆∞·ªõc n√†y v√† ti·∫øp t·ª•c...\n"
            return error_msg
        
        # N·∫øu kh√¥ng th·ªÉ ti·∫øp t·ª•c, d·ª´ng x·ª≠ l√Ω
        error_msg += "üõë Kh√¥ng th·ªÉ ti·∫øp t·ª•c, d·ª´ng x·ª≠ l√Ω.\n"
        return error_msg
    
    def _can_continue_with_context(self, missing_data: List[str]) -> bool:
        """Ki·ªÉm tra xem c√≥ th·ªÉ ti·∫øp t·ª•c v·ªõi d·ªØ li·ªáu hi·ªán c√≥ kh√¥ng"""
        for data_type in missing_data:
            if data_type == "search_keyword" and 'search_results' in self.context_data:
                return True
            if data_type == "file_list" and 'scan_results' in self.context_data:
                return True
            if data_type == "export_data" and any(key in self.context_data for key in 
                                                ['classify_results', 'scan_results', 'search_results']):
                return True
        return False
    
    def _can_skip_step(self, step_index: int, remaining_steps: List[Dict[str, Any]]) -> bool:
        """Ki·ªÉm tra xem c√≥ th·ªÉ b·ªè qua b∆∞·ªõc n√†y kh√¥ng"""
        # Logic ƒë·ªÉ quy·∫øt ƒë·ªãnh c√≥ th·ªÉ b·ªè qua b∆∞·ªõc n√†o
        # V√≠ d·ª•: c√≥ th·ªÉ b·ªè qua search n·∫øu ƒë√£ c√≥ scan results
        if step_index < len(remaining_steps) - 1:  # Kh√¥ng ph·∫£i b∆∞·ªõc cu·ªëi
            return True
        return False

def process_prompt_agent(prompt: str) -> str:
    """
    X·ª≠ l√Ω prompt nh∆∞ m·ªôt agentic AI v·ªõi kh·∫£ nƒÉng x·ª≠ l√Ω l·ªói v√† chuy·ªÉn ti·∫øp d·ªØ li·ªáu
    """
    try:
        # L·∫•y action plan t·ª´ prompt
        action_plan_data = get_json_response(prompt)
        
        # Ki·ªÉm tra xem c√≥ c·∫ßn s·ª≠ d·ª•ng MCP kh√¥ng
        if not MCP_AVAILABLE:
            print("MCP kh√¥ng kh·∫£ d·ª•ng, s·ª≠ d·ª•ng ch·∫ø ƒë·ªô ƒë∆°n gi·∫£n...")
            return generate_simple_response(prompt)
        
        # Ki·ªÉm tra xem c√≥ steps n√†o c·∫ßn x·ª≠ l√Ω kh√¥ng
        if not action_plan_data.steps or action_plan_data.steps[0].get('function') == 'general':
            print("Kh√¥ng c√≥ b∆∞·ªõc c·ª• th·ªÉ, s·ª≠ d·ª•ng ch·∫ø ƒë·ªô ƒë∆°n gi·∫£n...")
            return generate_simple_response(prompt)
        
        # Kh·ªüi t·∫°o processor
        processor = AgenticProcessor()
        final_result = f"üéØ ƒêang x·ª≠ l√Ω: {action_plan_data.task_description}\n\n"
        
        # Th·ª±c hi·ªán t·ª´ng b∆∞·ªõc
        for i, step in enumerate(action_plan_data.steps):
            step_result = processor.execute_step(step, i, prompt)
            
            if step_result.success:
                if len(step) > 1 : 
                    final_result += f"‚úÖ B∆∞·ªõc {i+1}: {step_result.data}\n"
                processor.execution_history.append({
                    'step': i+1,
                    'success': True,
                    'output': step_result.data
                })
            else:
                # X·ª≠ l√Ω l·ªói
                error_handling = processor.handle_step_failure(
                    step_result, i, action_plan_data.steps[i+1:], prompt
                )
                final_result += error_handling
                
                processor.execution_history.append({
                    'step': i+1,
                    'success': False,
                    'error': step_result.error
                })
                
                # Quy·∫øt ƒë·ªãnh c√≥ ti·∫øp t·ª•c hay kh√¥ng
                if "üõë" in error_handling:
                    break
        
        # Th√™m t√≥m t·∫Øt k·∫øt qu·∫£
        final_result += f"\nüìã T√≥m t·∫Øt: ƒê√£ th·ª±c hi·ªán {len(processor.execution_history)} b∆∞·ªõc"
        success_count = sum(1 for h in processor.execution_history if h['success'])
        final_result += f" ({success_count} th√†nh c√¥ng, {len(processor.execution_history) - success_count} th·∫•t b·∫°i)"
        if action_plan_data.recommendations != None  and action_plan_data.recommendations != "": 
            final_result += f"\nüí° G·ª£i √Ω: {action_plan_data.recommendations}"
        return final_result.strip()
        
    except Exception as e:
        print(f"Critical error in process_prompt_agent: {e}")
        return f"‚ùå L·ªói nghi√™m tr·ªçng: {str(e)}\nüîÑ Chuy·ªÉn sang ch·∫ø ƒë·ªô ƒë∆°n gi·∫£n..."